{"ast":null,"code":"var _jsxFileName = \"/Users/chairforce/workspace/turbyne/client/src/containers/LayoutContainer.tsx\";\nimport * as React from 'react';\nimport { ReactReduxContext } from 'react-redux';\nimport * as layoutActions from '../store/layout/actions'; // Now here is an example of creating container components.\n//\n// Before React v16 I would've suggested against implementing container components that are\n// separate from their connected view logic, since they intrude at the very definition of a view,\n// but now with newer patterns (e.g. render props), it makes sense to use them once again.\n//\n// See how this works at `./src/components/Header`\n// Redux-specific props.\n\nconst LayoutContainer = ({\n  render,\n  children\n}) => {\n  // Here we do a bit of a hack. Since the latest react-redux typings broke the\n  // \"children-props-as-redux-container\" approach on the previous version of this guide,\n  // we use the newly-introduced `ReactReduxContext` consumer to get our state, and map the\n  // `theme` state and the `setTheme` action call inside it.\n  return React.createElement(ReactReduxContext.Consumer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 34\n    },\n    __self: this\n  }, ({\n    store\n  }) => {\n    // Use the standard `store.getState()` redux function to get the root state, and cast\n    // it with our ApplicationState type.\n    const state = store.getState(); // Obtain the `theme` state and the `setTheme` action.\n    // Note that per Redux conventions actions MUST be wrapped inside `store.dispatch()`\n\n    const theme = state.layout.theme;\n\n    const setTheme = tc => store.dispatch(layoutActions.setTheme(tc)); // Create a render/children props wrapper with the above variables set as a callback.\n\n\n    if (render) {\n      return render({\n        theme,\n        setTheme\n      });\n    }\n\n    if (children) {\n      return children({\n        theme,\n        setTheme\n      });\n    }\n\n    return null;\n  });\n};\n\nexport default LayoutContainer;","map":{"version":3,"sources":["/Users/chairforce/workspace/turbyne/client/src/containers/LayoutContainer.tsx"],"names":["React","ReactReduxContext","layoutActions","LayoutContainer","render","children","store","state","getState","theme","layout","setTheme","tc","dispatch"],"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,iBAAT,QAAkC,aAAlC;AAIA,OAAO,KAAKC,aAAZ,MAA+B,yBAA/B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAYA,MAAMC,eAAqD,GAAG,CAAC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA;AAAV,CAAD,KAA0B;AACpF;AACA;AACA;AACA;AACA,SACI,oBAAC,iBAAD,CAAmB,QAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACK,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAe;AACZ;AACA;AACA,UAAMC,KAAuB,GAAGD,KAAK,CAACE,QAAN,EAAhC,CAHY,CAKZ;AACA;;AANY,UAOJC,KAPI,GAOMF,KAAK,CAACG,MAPZ,CAOJD,KAPI;;AAQZ,UAAME,QAAQ,GAAIC,EAAD,IAAqBN,KAAK,CAACO,QAAN,CAAeX,aAAa,CAACS,QAAd,CAAuBC,EAAvB,CAAf,CAAtC,CARY,CAUZ;;;AACA,QAAIR,MAAJ,EAAY;AACR,aAAOA,MAAM,CAAC;AAAEK,QAAAA,KAAF;AAASE,QAAAA;AAAT,OAAD,CAAb;AACH;;AAED,QAAIN,QAAJ,EAAc;AACV,aAAOA,QAAQ,CAAC;AAAEI,QAAAA,KAAF;AAASE,QAAAA;AAAT,OAAD,CAAf;AACH;;AAED,WAAO,IAAP;AACH,GArBL,CADJ;AAyBH,CA9BD;;AAgCA,eAAeR,eAAf","sourcesContent":["import * as React from 'react';\nimport { ReactReduxContext } from 'react-redux';\n\nimport { ApplicationState } from '../store';\nimport { ThemeColors } from '../store/layout';\nimport * as layoutActions from '../store/layout/actions';\n\n// Now here is an example of creating container components.\n//\n// Before React v16 I would've suggested against implementing container components that are\n// separate from their connected view logic, since they intrude at the very definition of a view,\n// but now with newer patterns (e.g. render props), it makes sense to use them once again.\n//\n// See how this works at `./src/components/Header`\n\n// Redux-specific props.\ninterface LayoutContainerProps {\n    theme: ThemeColors;\n    setTheme: (theme: ThemeColors) => void;\n}\n\n// Wrapper props for render/children callback.\ninterface LayoutContainerRenderProps {\n    render?: (props: LayoutContainerProps) => React.ReactNode;\n    children?: (props: LayoutContainerProps) => React.ReactNode;\n}\n\nconst LayoutContainer: React.FC<LayoutContainerRenderProps> = ({ render, children }) => {\n    // Here we do a bit of a hack. Since the latest react-redux typings broke the\n    // \"children-props-as-redux-container\" approach on the previous version of this guide,\n    // we use the newly-introduced `ReactReduxContext` consumer to get our state, and map the\n    // `theme` state and the `setTheme` action call inside it.\n    return (\n        <ReactReduxContext.Consumer>\n            {({ store }) => {\n                // Use the standard `store.getState()` redux function to get the root state, and cast\n                // it with our ApplicationState type.\n                const state: ApplicationState = store.getState();\n\n                // Obtain the `theme` state and the `setTheme` action.\n                // Note that per Redux conventions actions MUST be wrapped inside `store.dispatch()`\n                const { theme } = state.layout;\n                const setTheme = (tc: ThemeColors) => store.dispatch(layoutActions.setTheme(tc));\n\n                // Create a render/children props wrapper with the above variables set as a callback.\n                if (render) {\n                    return render({ theme, setTheme });\n                }\n\n                if (children) {\n                    return children({ theme, setTheme });\n                }\n\n                return null;\n            }}\n        </ReactReduxContext.Consumer>\n    );\n};\n\nexport default LayoutContainer;\n"]},"metadata":{},"sourceType":"module"}