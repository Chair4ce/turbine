{"ast":null,"code":"// Example for using discriminated union types.\n// Use enums for better autocompletion of action type names. These will\n// be compiled away leaving only the final value in your compiled code.\n//\n// Define however naming conventions you'd like for your action types, but\n// personally, I use the `@@context/ACTION_TYPE` convention, to follow the convention\n// of Redux's `@@INIT` action.\nexport let LayoutActionTypes; // Declare state types with `readonly` modifier to get compile time immutability.\n// https://github.com/piotrwitek/react-redux-typescript-guide#state-with-type-level-immutability\n\n(function (LayoutActionTypes) {\n  LayoutActionTypes[\"SET_THEME\"] = \"@@layout/SET_THEME\";\n})(LayoutActionTypes || (LayoutActionTypes = {}));","map":{"version":3,"sources":["/Users/chairforce/workspace/turbyne/client/src/store/layout/types.ts"],"names":["LayoutActionTypes"],"mappings":"AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAYA,iBAAZ,C,CAIA;AACA;;WALYA,iB;AAAAA,EAAAA,iB;GAAAA,iB,KAAAA,iB","sourcesContent":["// Example for using discriminated union types.\nexport type ThemeColors = 'light' | 'dark';\n\n// Use enums for better autocompletion of action type names. These will\n// be compiled away leaving only the final value in your compiled code.\n//\n// Define however naming conventions you'd like for your action types, but\n// personally, I use the `@@context/ACTION_TYPE` convention, to follow the convention\n// of Redux's `@@INIT` action.\nexport enum LayoutActionTypes {\n    SET_THEME = '@@layout/SET_THEME',\n}\n\n// Declare state types with `readonly` modifier to get compile time immutability.\n// https://github.com/piotrwitek/react-redux-typescript-guide#state-with-type-level-immutability\nexport interface LayoutState {\n    readonly theme: ThemeColors;\n}\n"]},"metadata":{},"sourceType":"module"}