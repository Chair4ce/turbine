{"ast":null,"code":"import*as React from'react';import{ReactReduxContext}from'react-redux';import*as layoutActions from'../store/layout/actions';// Now here is an example of creating container components.\n//\n// Before React v16 I would've suggested against implementing container components that are\n// separate from their connected view logic, since they intrude at the very definition of a view,\n// but now with newer patterns (e.g. render props), it makes sense to use them once again.\n//\n// See how this works at `./src/components/Header`\n// Redux-specific props.\nvar LayoutContainer=function LayoutContainer(_ref){var render=_ref.render,children=_ref.children;// Here we do a bit of a hack. Since the latest react-redux typings broke the\n// \"children-props-as-redux-container\" approach on the previous version of this guide,\n// we use the newly-introduced `ReactReduxContext` consumer to get our state, and map the\n// `theme` state and the `setTheme` action call inside it.\nreturn React.createElement(ReactReduxContext.Consumer,null,function(_ref2){var store=_ref2.store;// Use the standard `store.getState()` redux function to get the root state, and cast\n// it with our ApplicationState type.\nvar state=store.getState();// Obtain the `theme` state and the `setTheme` action.\n// Note that per Redux conventions actions MUST be wrapped inside `store.dispatch()`\nvar theme=state.layout.theme;var setTheme=function setTheme(tc){return store.dispatch(layoutActions.setTheme(tc));};// Create a render/children props wrapper with the above variables set as a callback.\nif(render){return render({theme:theme,setTheme:setTheme});}if(children){return children({theme:theme,setTheme:setTheme});}return null;});};export default LayoutContainer;","map":{"version":3,"sources":["/Users/ridley/workspace/turbine/client/src/containers/LayoutContainer.tsx"],"names":["React","ReactReduxContext","layoutActions","LayoutContainer","render","children","store","state","getState","theme","layout","setTheme","tc","dispatch"],"mappings":"AAAA,MAAO,GAAKA,CAAAA,KAAZ,KAAuB,OAAvB,CACA,OAASC,iBAAT,KAAkC,aAAlC,CAIA,MAAO,GAAKC,CAAAA,aAAZ,KAA+B,yBAA/B,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAYA,GAAMC,CAAAA,eAAqD,CAAG,QAAxDA,CAAAA,eAAwD,MAA0B,IAAvBC,CAAAA,MAAuB,MAAvBA,MAAuB,CAAfC,QAAe,MAAfA,QAAe,CACpF;AACA;AACA;AACA;AACA,MACI,qBAAC,iBAAD,CAAmB,QAAnB,MACK,eAAe,IAAZC,CAAAA,KAAY,OAAZA,KAAY,CACZ;AACA;AACA,GAAMC,CAAAA,KAAuB,CAAGD,KAAK,CAACE,QAAN,EAAhC,CAEA;AACA;AANY,GAOJC,CAAAA,KAPI,CAOMF,KAAK,CAACG,MAPZ,CAOJD,KAPI,CAQZ,GAAME,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACC,EAAD,QAAqBN,CAAAA,KAAK,CAACO,QAAN,CAAeX,aAAa,CAACS,QAAd,CAAuBC,EAAvB,CAAf,CAArB,EAAjB,CAEA;AACA,GAAIR,MAAJ,CAAY,CACR,MAAOA,CAAAA,MAAM,CAAC,CAAEK,KAAK,CAALA,KAAF,CAASE,QAAQ,CAARA,QAAT,CAAD,CAAb,CACH,CAED,GAAIN,QAAJ,CAAc,CACV,MAAOA,CAAAA,QAAQ,CAAC,CAAEI,KAAK,CAALA,KAAF,CAASE,QAAQ,CAARA,QAAT,CAAD,CAAf,CACH,CAED,MAAO,KAAP,CACH,CArBL,CADJ,CAyBH,CA9BD,CAgCA,cAAeR,CAAAA,eAAf","sourcesContent":["import * as React from 'react';\nimport { ReactReduxContext } from 'react-redux';\n\nimport { ApplicationState } from '../store';\nimport { ThemeColors } from '../store/layout';\nimport * as layoutActions from '../store/layout/actions';\n\n// Now here is an example of creating container components.\n//\n// Before React v16 I would've suggested against implementing container components that are\n// separate from their connected view logic, since they intrude at the very definition of a view,\n// but now with newer patterns (e.g. render props), it makes sense to use them once again.\n//\n// See how this works at `./src/components/Header`\n\n// Redux-specific props.\ninterface LayoutContainerProps {\n    theme: ThemeColors;\n    setTheme: (theme: ThemeColors) => void;\n}\n\n// Wrapper props for render/children callback.\ninterface LayoutContainerRenderProps {\n    render?: (props: LayoutContainerProps) => React.ReactNode;\n    children?: (props: LayoutContainerProps) => React.ReactNode;\n}\n\nconst LayoutContainer: React.FC<LayoutContainerRenderProps> = ({ render, children }) => {\n    // Here we do a bit of a hack. Since the latest react-redux typings broke the\n    // \"children-props-as-redux-container\" approach on the previous version of this guide,\n    // we use the newly-introduced `ReactReduxContext` consumer to get our state, and map the\n    // `theme` state and the `setTheme` action call inside it.\n    return (\n        <ReactReduxContext.Consumer>\n            {({ store }) => {\n                // Use the standard `store.getState()` redux function to get the root state, and cast\n                // it with our ApplicationState type.\n                const state: ApplicationState = store.getState();\n\n                // Obtain the `theme` state and the `setTheme` action.\n                // Note that per Redux conventions actions MUST be wrapped inside `store.dispatch()`\n                const { theme } = state.layout;\n                const setTheme = (tc: ThemeColors) => store.dispatch(layoutActions.setTheme(tc));\n\n                // Create a render/children props wrapper with the above variables set as a callback.\n                if (render) {\n                    return render({ theme, setTheme });\n                }\n\n                if (children) {\n                    return children({ theme, setTheme });\n                }\n\n                return null;\n            }}\n        </ReactReduxContext.Consumer>\n    );\n};\n\nexport default LayoutContainer;\n"]},"metadata":{},"sourceType":"module"}