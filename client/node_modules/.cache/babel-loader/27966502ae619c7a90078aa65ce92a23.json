{"ast":null,"code":"import*as React from'react';import{connect}from'react-redux';import{Route,Switch}from'react-router-dom';import MembersIndexPage from'./members/index';import ShowMembersPage from'./members/show';var MembersPage=function MembersPage(_ref){var match=_ref.match;return React.createElement(Switch,null,React.createElement(Route,{exact:true,path:\"\".concat(match.path,\"/\"),component:MembersIndexPage}),React.createElement(Route,{path:\"\".concat(match.path,\"/:memberId\"),component:ShowMembersPage}));};// It's usually good practice to only include one context at a time in a connected component.\n// Although if necessary, you can always include multiple contexts. Just make sure to\n// separate them from each other to prevent prop conflicts.\nvar mapStateToProps=function mapStateToProps(_ref2){var members=_ref2.members;return{loading:members.loading,data:members.data};};// Now let's connect our component!\n// With redux v4's improved typings, we can finally omit generics here.\nexport default connect(mapStateToProps)(MembersPage);","map":{"version":3,"sources":["/Users/chairforce/workspace/turbyne/client/src/pages/members.tsx"],"names":["React","connect","Route","Switch","MembersIndexPage","ShowMembersPage","MembersPage","match","path","mapStateToProps","members","loading","data"],"mappings":"AAAA,MAAO,GAAKA,CAAAA,KAAZ,KAAuB,OAAvB,CACA,OAASC,OAAT,KAAwB,aAAxB,CACA,OAA8BC,KAA9B,CAAqCC,MAArC,KAAmD,kBAAnD,CAEA,MAAOC,CAAAA,gBAAP,KAA6B,iBAA7B,CACA,MAAOC,CAAAA,eAAP,KAA4B,gBAA5B,CAcA,GAAMC,CAAAA,WAA+B,CAAG,QAAlCA,CAAAA,WAAkC,MAAe,IAAZC,CAAAA,KAAY,MAAZA,KAAY,CACnD,MACI,qBAAC,MAAD,MACI,oBAAC,KAAD,EAAO,KAAK,KAAZ,CAAa,IAAI,WAAKA,KAAK,CAACC,IAAX,KAAjB,CAAqC,SAAS,CAAEJ,gBAAhD,EADJ,CAEI,oBAAC,KAAD,EAAO,IAAI,WAAKG,KAAK,CAACC,IAAX,cAAX,CAAwC,SAAS,CAAEH,eAAnD,EAFJ,CADJ,CAMH,CAPD,CASA;AACA;AACA;AACA,GAAMI,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,WAAGC,CAAAA,OAAH,OAAGA,OAAH,OAAoC,CACxDC,OAAO,CAAED,OAAO,CAACC,OADuC,CAExDC,IAAI,CAAEF,OAAO,CAACE,IAF0C,CAApC,EAAxB,CAKA;AACA;AACA,cAAeX,CAAAA,OAAO,CAACQ,eAAD,CAAP,CAAyBH,WAAzB,CAAf","sourcesContent":["import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { RouteComponentProps, Route, Switch } from 'react-router-dom';\n\nimport MembersIndexPage from './members/index';\nimport ShowMembersPage from './members/show';\n\nimport { ApplicationState } from '../store';\nimport { Member } from '../store/members/types';\n\n// Separate state props + dispatch props to their own interfaces.\ninterface PropsFromState {\n    loading: boolean;\n    data: Member[];\n}\n\n// Combine both state + dispatch props - as well as any props we want to pass - in a union type.\ntype AllProps = PropsFromState & RouteComponentProps;\n\nconst MembersPage: React.FC<AllProps> = ({ match }) => {\n    return (\n        <Switch>\n            <Route exact path={`${match.path}/`} component={MembersIndexPage} />\n            <Route path={`${match.path}/:memberId`} component={ShowMembersPage} />\n        </Switch>\n    );\n};\n\n// It's usually good practice to only include one context at a time in a connected component.\n// Although if necessary, you can always include multiple contexts. Just make sure to\n// separate them from each other to prevent prop conflicts.\nconst mapStateToProps = ({ members }: ApplicationState) => ({\n    loading: members.loading,\n    data: members.data,\n});\n\n// Now let's connect our component!\n// With redux v4's improved typings, we can finally omit generics here.\nexport default connect(mapStateToProps)(MembersPage);\n"]},"metadata":{},"sourceType":"module"}